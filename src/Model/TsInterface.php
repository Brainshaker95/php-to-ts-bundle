<?php

declare(strict_types=1);

namespace Brainshaker95\PhpToTsBundle\Model;

use Brainshaker95\PhpToTsBundle\Interface\Config as C;
use Brainshaker95\PhpToTsBundle\Interface\FileNameStrategy;
use Brainshaker95\PhpToTsBundle\Interface\SortStrategy;
use Brainshaker95\PhpToTsBundle\Model\Config\FileType;
use Brainshaker95\PhpToTsBundle\Model\Config\Indent;
use Brainshaker95\PhpToTsBundle\Model\Config\Quotes;
use Stringable;

use const PHP_EOL;

use function array_count_values;
use function array_filter;
use function array_map;
use function array_unshift;
use function current;
use function implode;
use function in_array;
use function natcasesort;
use function sprintf;
use function usort;

final class TsInterface implements Stringable
{
    /**
     * @param TsGeneric[] $generics
     * @param TsProperty[] $properties
     * @param true|string|null $deprecation
     */
    public function __construct(
        public string $name,
        public ?string $parentName = null,
        public readonly bool $isReadonly = false,
        public readonly array $generics = [],
        public ?string $description = null,
        public bool|string|null $deprecation = null,
        public array $properties = [],
    ) {
    }

    public function __toString(): string
    {
        return $this->toString();
    }

    public function addProperty(TsProperty $property): self
    {
        $this->properties[] = $property;

        return $this;
    }

    /**
     * @phpstan-param FileType::TYPE_* $fileType
     * @param class-string<SortStrategy>[] $sortStrategies
     * @param class-string<FileNameStrategy> $fileNameStrategy
     */
    public function toString(
        string $fileType = C::FILE_TYPE_DEFAULT,
        Indent $indent = new Indent(),
        Quotes $quotes = new Quotes(),
        array $sortStrategies = C::SORT_STRATEGIES_DEFAULT,
        string $fileNameStrategy = C::FILE_NAME_STRATEGY_DEFAULT,
    ): string {
        $isModule         = $fileType === FileType::TYPE_MODULE;
        $imports          = $isModule ? $this->getImports($fileNameStrategy, $quotes) : [];
        $sortedProperties = self::getSortedProperties($sortStrategies);
        $generics         = $this->getGenerics($sortedProperties);

        $header = (new TsDocComment(
            description: "Auto-generated by PhpToTsBundle\nDo not modify directly!",
        ))->toString();

        $docComment = (new TsDocComment(
            description: $this->description,
            deprecation: $this->deprecation,
            generics: $generics,
        ))->toString();

        return $header . PHP_EOL . PHP_EOL
            . (!empty($imports) ? implode(PHP_EOL, $imports) . PHP_EOL . PHP_EOL : '')
            . ($docComment ? ($docComment . PHP_EOL) : '')
            . sprintf(
                '%s interface %s%s%s {' . PHP_EOL . '%s' . PHP_EOL . '}',
                $isModule ? 'export' : 'declare',
                $this->name,
                TsGeneric::multipleToString($generics, $indent, $quotes),
                $this->parentName ? ' extends ' . $this->parentName : '',
                implode(PHP_EOL, array_map(
                    static fn (TsProperty $property) => $property->toString($indent, $quotes),
                    $sortedProperties,
                )),
            );
    }

    /**
     * @phpstan-param FileType::TYPE_* $fileType
     * @param class-string<FileNameStrategy> $fileNameStrategy
     */
    public function getFileName(
        string $fileType = C::FILE_TYPE_DEFAULT,
        string $fileNameStrategy = C::FILE_NAME_STRATEGY_DEFAULT,
    ): string {
        return (new $fileNameStrategy())->getName($this->name)
            . ($fileType === FileType::TYPE_DECLARATION ? '.d' : '')
            . '.ts';
    }

    /**
     * @param class-string<SortStrategy>[] $sortStrategies
     *
     * @return TsProperty[]
     */
    private function getSortedProperties(array $sortStrategies): array
    {
        $properties = $this->properties;

        foreach ($sortStrategies as $sortStrategy) {
            usort(
                $properties,
                static fn (TsProperty $prop1, TsProperty $prop2) => (new $sortStrategy())->sort($prop1, $prop2),
            );
        }

        return $properties;
    }

    /**
     * @param class-string<FileNameStrategy> $fileNameStrategy
     *
     * @return string[]
     */
    private function getImports(string $fileNameStrategy, Quotes $quotes): array
    {
        $imports      = $this->parentName ? [$this->parentName] : [];
        $genericNames = TsGeneric::getNames($this->generics);

        foreach ($this->properties as $property) {
            foreach ($property->classIdentifiers as $classIdentifier) {
                if (!in_array($classIdentifier, $imports, true)
                    && !in_array($classIdentifier, $genericNames, true)) {
                    $imports[] = $classIdentifier;
                }
            }
        }

        natcasesort($imports);

        $fileNameStrategyInstance = new $fileNameStrategy();

        return array_map(
            static fn (string $classIdentifier) => sprintf(
                'import type { %s } from %s',
                $classIdentifier,
                $quotes->toString('./' . $fileNameStrategyInstance->getName($classIdentifier)) . ';',
            ),
            $imports,
        );
    }

    /**
     * @param TsProperty[] $properties
     *
     * @return TsGeneric[]
     */
    private function getGenerics(array $properties): array
    {
        $generics = [];

        foreach ($properties as $property) {
            foreach ($property->generics as $generic) {
                if (!$property->isConstructorProperty) {
                    $generics[]          = $generic;
                    $generic->properties = [...$generic->properties, $property];

                    continue;
                }

                $alreadyAddedGeneric = current(array_filter(
                    $generics,
                    static fn (TsGeneric $referenceGeneric) => $referenceGeneric->name === $generic->name,
                ));

                if ($alreadyAddedGeneric) {
                    $alreadyAddedGeneric->properties = [...$alreadyAddedGeneric->properties, $property];
                } else {
                    $generics[]          = $generic;
                    $generic->properties = [...$generic->properties, $property];
                }
            }
        }

        foreach ($this->generics as $generic) {
            $propertiesWithGeneric = array_filter(
                $this->properties,
                static fn (TsProperty $property) => in_array($generic->name, $property->classIdentifiers, true),
            );

            if (empty($propertiesWithGeneric)) {
                continue;
            }

            array_unshift($generics, $generic);

            foreach ($propertiesWithGeneric as $propertyWithGeneric) {
                $generic->properties = [...$generic->properties, $propertyWithGeneric];
            }
        }

        $this->renameGenerics($generics);

        usort($generics, static fn (TsGeneric $generic) => $generic->default ? 1 : -1);

        return $generics;
    }

    /**
     * @param TsGeneric[] $generics
     */
    private function renameGenerics(array $generics): void
    {
        $usageCounts = array_count_values(TsGeneric::getNames($generics));

        foreach ($generics as $generic) {
            $name = $generic->name;

            if ($usageCounts[$name] === 1) {
                continue;
            }

            $usedNames[$name] = ($usedNames[$name] ?? 0) + 1;
            $generic->name    = $name . $usedNames[$name];

            foreach ($generic->properties as $property) {
                $property->applyNewGenericName(
                    oldName: $name,
                    newName: $generic->name,
                    generics: $generics,
                );
            }
        }
    }
}
